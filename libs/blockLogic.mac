%ifndef BLOCKLOGIC_MAC
    %define BLOCKLOGIC_MAC
    ;; ------------------------------------MACROS--------------------------------------------
    %macro blockPos 0
        mov si, actualGridPos
        sub ax, si
        div 16
    %endmacro

    %macro bitCheckFill 0
        mov bx, [gridArray + si]
        and bx, 000100000000000 ;bitmask to check if filled
        jnz nothing
        call updateBlock
    %endmacro

    %macro modOP 1
        push al
        div %1
        pop ch
        mul %1
        sub ch, al
    %endmacro

    %macro movementMacro
        mov ax, gridArray
        mov bl, directionKey
        cmp bl,0x77 ; bl is 'w'?
        je upMov
        cmp bl, 0x61 ;bil is 'a'
        je leftMov
        cmp bl, 0x64 ;bl is 'd'
        je rightMov
        cmp bl, 0x73 ;bl is 's'
    %endmacro

    %macro checkIfEqual
        mov ax, [actualGridPos]
        mov dx, [gridArray + si]
        mov bx, 0000111111111111
        and bx, ax              ;apply bitmask to bx
        and dx, bx              ;apply bitmask to dx
        cmp dx, bx              ;check if both are equal
    %endmacro

    %macro scoreINC
        mov dx, [score]
        mov bx, 0000011111111111
        and bx, ax
        add [dx], bx
    %endmacro

    %macro multiplyValueBy2
        mov bx, 1111111111111111
        shl ax
        and ax, bx
        mov bx, 00000100000000000 ;check if 2048 has been achieved
        and bx, ax
        jnz winScreen
    %endmacro

    ;; ---------------------------------ROUTINES----------------------------------------------
    loopGrid:
        mov bx, gridArray ;start of grid
        mov si, 0
        mov cl, 0               ;counter
        .loop:
            mov [actualGridPos], bx
            call dx ;dx will be the address of one of the "block functions"
            inc si
            mov bx, [gridArray+2*si] ;loop through the array, 2bytes = 1w per "array index"
            cmp si, 16
            jne .loop
        ret

    moveBlocks:
        pusha
        mov dx, bitCheckFill
        movementMacro
        nothing1:
            popa
            ret

    directionMatch:
        pusha
        mov dx, blockMatch
        movementMacro
        jmp nothing1

    blockMatch:
        checkIfEqual
        jne nothing1
        multiplyValueBy2
        scoreINC
        mov [actualGridPos], ax
            updateBlock:
            mov dx, actualGridPos
            mov [gridArray + si], dx
            mov [dx], 0000000000000000 ;reset the state
            ret

    fillBlock:
        pusha
        getRandom
        mov [actualGridPos + 2*si], 0001000000000010
        popa
        ret

    isGameOver:
        cmp cl, 16
        je gameOverScreen
        cmp [bx], 0
        jnz counterINC
            nothing2:
                ret

    counterINC:
        inc cl
        jmp nothing2


    upMov:
        blockPos
        cmp al, 4               ;specific to this case
        jl nothing1
        mov si, al
        sub si, 3               ;index above the position
        call dx
        jmp nothing1


    downMov:
        blockPos
        cmp al, 11
        jg nothing1
        mov si, al
        add si, 3
        call dx
        jmp nothing1

    leftMov:
        blockPos
        mov bh, al
        modOP 4
        jz nothing1            ;0,4,8,12 boundaries
        mov si, bh
        dec si
        call dx
        jmp nothing1

    rightMov:
        blockPos
        mov bh, al
        modOP 4
        cmp si, 3               ;3, 7,11,15 boundaries
        je nothing1
        mov si, bh
        inc si
        call dx
        jmp nothing1

%endif
